<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python 练习（一）]]></title>
    <url>%2Fgit-gao.github.io%2F2018%2F07%2F08%2FPython-%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[python 练习系列（一）你有一个目录，装了很多照片，把它们的尺寸变成不大于 iPhone5 分辨率的大小。(1136*640) 思路:1.遍历文件夹2.循环处理照片3.保存照片到新的文件夹 代码实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243import osfrom PIL import Image# 遍历文件夹获取照片def getImg(): dirName = "004Image" newDirName = dirName + "_new" # 创建文件夹 if os.path.exists(newDirName) == False: os.mkdir(newDirName) # listdir() 是文件夹操作方法，返回的是一个列表对象 for imgName in os.listdir(dirName): print(imgName) img = Image.open(dirName + "//" + imgName) newImg = imgHandle(img) # 保存到新的文件夹中 newImg.save(os.path.join(newDirName, os.path.basename(imgName)))# 图片处理def imgHandle(img): # IPHONE 5 的尺寸大小 IPHONE5_WIDTH = 1136 IPHONE5_HEIGHT = 640 # 获取图片大小 imgW, imgH = imgSize = img.size newImgSize = imgSize # 如果图片的宽或高大于 iphone5 的宽或高，则等比例缩小尺寸 if imgW &gt; IPHONE5_WIDTH: imgH = IPHONE5_WIDTH * imgW // imgH imgW = IPHONE5_WIDTH if imgH &gt; IPHONE5_HEIGHT: imgW = IPHONE5_HEIGHT * imgW // imgH imgH = IPHONE5_HEIGHT newImg = img.resize((imgW, imgH), Image.ANTIALIAS) return newImgif __name__ == "__main__": getImg() 欢迎关注公众号: 一碗杂货店]]></content>
      <tags>
        <tag>Python练习系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存流]]></title>
    <url>%2Fgit-gao.github.io%2F2018%2F05%2F11%2F%E7%BC%93%E5%AD%98%E6%B5%81%2F</url>
    <content type="text"><![CDATA[BufferedInputStream 和 BufferedOutputStream 这两个类分别是FilterInputStream 和 FilterOutputStream的子类，作为装饰器子类，使用它们可以防止每次读取/发送数据时进行实际的写操作，代表着使用缓冲区。 以介质是硬盘为例，字节流和字符流的弊端：在每一次读写的时候，都会访问硬盘。 如果读写的频率比较高的时候，其性能表现不佳。 为了解决以上弊端，采用缓存流。缓存流在读取的时候，会一次性读较多的数据到缓存中，以后每一次的读取，都是在缓存中访问，直到缓存中的数据读取完毕，再到硬盘中读取。 就好比吃饭，不用缓存就是每吃一口都到锅里去铲。用缓存就是先把饭盛到碗里，碗里的吃完了，再到锅里去铲 缓存流在写入数据的时候，会先把数据写入到缓存区，直到缓存区达到一定的量，才把这些数据，一起写入到硬盘中去。按照这种操作模式，就不会像字节流，字符流那样每写一个字节都访问硬盘，从而减少了IO操作 使用缓存流读取数据以下代码使用 try-with-resourses 自动关闭资源 缓存字符输入流 BufferedReader 可以一次读取一行数据12345678910111213141516171819202122232425public static void main(String[] args) &#123; // 准备文件buffer.txt其中的内容是： //1. import java.io.BufferedReader; //2. import java.io.BufferedWriter; //3. import java.io.FileInputStream; File file = new File(&quot;F:/winner_info/Learnhow2j/JavaSystem/src/TestBuffer/buffer.txt&quot;); try( // 创建文件字符流 FileReader fr = new FileReader(file); // 缓存流必须建立在一个存在的流的基础上 BufferedReader br = new BufferedReader(fr); )&#123; while (true) &#123; // 一次读一行 String line = br.readLine(); if (null == line) break; System.out.println(line); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;&#125; 输出结果： import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; 使用缓存流写出数据PrintWriter 缓存字符输出流， 可以一次写出一行数据123456789101112131415161718public static void main(String[] args) &#123; File file = new File(&quot;F:/winner_info/Learnhow2j/JavaSystem/src/TestBuffer/bufferWriter.txt&quot;); // 创建文件字符流 // 缓存流必须建立在一个存在的流的基础上 try( // 创建文件字符流 //再次运行内容不会被覆盖，在原内容后继续追加 FileWriter fw = new FileWriter(file,true); // 缓存流必须建立在一个存在的流的基础上 BufferedWriter bw = new BufferedWriter(fw); )&#123; bw.write(&quot;这是第一句话！！！&quot;); bw.write(&quot;这是第二句话！！！&quot;); bw.write(&quot;这是第三句话！！！&quot;); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;&#125; 文件内容： 这是第一句话！！！这是第二句话！！！这是第三句话！！！]]></content>
      <categories>
        <category>Java文件</category>
      </categories>
      <tags>
        <tag>java流、javaI/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码问题]]></title>
    <url>%2Fgit-gao.github.io%2F2018%2F05%2F11%2F%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[如果说我们把计算机能理解的语言定义为英语，其它语言要能够在计算机中使用必须经过一次翻译，把它翻译成英语。这个翻译的过程就是编码。 编码的原因可以总结为： 计算机中存储信息的最小单元是一个字节即 8 个 bit，所以能表示的字符范围是 0~255 个 人类要表示的符号太多，无法用一个字节来完全表示 要解决这个矛盾必须需要一个新的数据结构 char，从 char 到 byte 必须编码 如何翻译明白了各种语言需要交流，经过翻译是必要的，那又如何来翻译呢？计算中提拱了多种翻译方式，常见的有 ASCII、ISO-8859-1、GB2312、GBK、UTF-8、UTF-16 等。 ASCII 码 学过计算机的人都知道 ASCII 码，总共有 128 个，用一个字节的低 7 位表示，0~31 是控制字符如换行回车删除等；32~126 是打印字符，可以通过键盘输入并且能够显示出来。 ISO-8859-1 128 个字符显然是不够用的，于是 ISO 组织在 ASCII 码基础上又制定了一些列标准用来扩展 ASCII 编码，它们是 ISO-8859-1~ISO-8859-15，其中 ISO-8859-1 涵盖了大多数西欧语言字符，所有应用的最广泛。ISO-8859-1 仍然是单字节编码，它总共能表示 256 个字符。 GB2312 它的全称是《信息交换用汉字编码字符集 基本集》，它是双字节编码，总的编码范围是 A1-F7，其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，包含 6763 个汉字。 GBK 全称叫《汉字内码扩展规范》，是国家技术监督局为 windows95 所制定的新的汉字内码规范，它的出现是为了扩展 GB2312，加入更多的汉字，它的编码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。 UTF-16说到 UTF 必须要提到 Unicode（Universal Code 统一码），ISO 试图想创建一个全新的超语言字典，世界上所有的语言都可以通过这本字典来相互翻译。可想而知这个字典是多么的复杂，关于 Unicode 的详细规范可以参考相应文档。Unicode 是 Java 和 XML 的基础，下面详细介绍 Unicode 在计算机中的存储形式。 UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。 UTF-8UTF-16 统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。 UTF-8 有以下编码规则： 如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASCII 字符（00 - 7F）。可见，所有 ASCII 编码已经是 UTF-8 了。 如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。 如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节 用FileReader 字符流正确读取中文 FileReader得到的是字符，所以一定是已经把字节根据某种编码识别成了字符了而FileReader使用的编码方式是Charset.defaultCharset()的返回值，如果是中文的操作系统，就是GBKFileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替，像这样： InputStreamReader 类 是字节流通向字符流的桥梁,封裝了InputStream在里头, 它以较高级的方式,一次读取一个一个字符，以文本格式输入 / 输出，可以指定编码格式； 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; File file = new File("F:/winner_info/Learnhow2j/JavaSystem/src/TestFileStream/textStream.txt"); System.out.println("默认的编码方式："+Charset.defaultCharset()); try(FileReader fr = new FileReader(file))&#123; //创建字符数组 char[] cs = new char [(int) file.length()]; fr.read(cs); System.out.printf("FileReader会使用默认的编码方式%s,识别出来的字符是：%n",Charset.defaultCharset()); System.out.println(new String(cs)); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; //FileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替 //并且使用new InputStreamReader(new FileInputStream(f),Charset.forName("UTF-8")); 这样的形式 try(InputStreamReader isr = new InputStreamReader(new FileInputStream(file),Charset.forName("UTF-8")))&#123; //创建字符数组 char[] cs = new char [(int) file.length()]; isr.read(cs); System.out.printf("InputStreamReader 指定编码方式UTF-8,识别出来的字符是：%n"); System.out.println(new String(cs)); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;&#125;]]></content>
      <tags>
        <tag>java中文编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符流]]></title>
    <url>%2Fgit-gao.github.io%2F2018%2F04%2F27%2F%E5%AD%97%E7%AC%A6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[字符流我们先来看看常说的字符与字节的的定义：（一）“字节”的定义 字节（Byte）是一种计量单位，表示数据量多少，它是计算机信息技术用于计量存储容量的一种计量单位。1个字节等于8位二进制，它是一个8位的二进制数，是一个很具体的存储空间。 （二）“字符”的定义 字符是指计算机中使用的文字和符号，比如1、2、3、A、B、C、~！·#￥%……—*（）——+、等等 前面讲的都是InputStream，这是操作字节流的类，然而我们在程序中往往要从文件等stream中读取字符信息，如果只用InputStream能否读取字符信息呢？当然可以。但是这涉及到了一个编码和解码的问题，传输双方必须才用同一种编码方式才能正确接收，这就导致每次在传输时，传输方需要做这么几件事： 1）将需要传输的字符编码成指定字节 2）传输字节 接收方需要做这么几件事： 1）接收字节 2）将字节解码成对应的字符12345678910111213141516171819public static void main(String[] args) &#123; File file = new File("F:/winner_info/Learnhow2j/JavaSystem/src/TestFileStream/textStream.txt"); //把流定义在try()里,try,catch或者finally结束的时候，会自动关闭 try(FileInputStream fis = new FileInputStream(file))&#123; //创建字节数组，其长度就是文件的长度 byte[] all = new byte[(int) file.length()]; int length = fis.read(all); for (byte b : all)&#123; System.out.println(b); &#125; // 将字节数组中指定位置的字节转码成对应的字符串 String content = new String(all, 0, length, Charset.forName("GBK")); System.out.println("the content is " + content); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; 可以看到文本内容：i am ok 你好！输出结果：the content is： i am ok 你好！ 从上面的例子中，我们看到只有InputStream就能解决传输字符串的问题了，但是每次都要先读成byte字节，再进行转码，麻烦，能不能直接传字符呢？？？？？ Reader字符输入流Writer字符输出流专门用于字符的形式读取和写入数据 使用字符流读取文件1234567891011121314public static void main(String[] args) &#123; File file = new File("F:/winner_info/Learnhow2j/JavaSystem/src/TestFileStream/textStream.txt"); // 创建基于文件的Reader try(FileReader fr = new FileReader(file))&#123; // 创建字符数组，其长度就是文件的长度 char[] all = new char[(int) file.length()]; fr.read(all); System.out.println(all); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; 输出结果： 使用字符流把字符串写入到文件123456789101112131415public static void main(String[] args) &#123; File file = new File(&quot;F:/winner_info/Learnhow2j/JavaSystem/src/TestFileStream/textStream.txt&quot;); // 创建基于文件的Reader try(FileWriter fw = new FileWriter(file))&#123; // 以字符流的形式把数据写入到文件中 String data=&quot;我是writer!!!&quot;; // 创建字符数组，其长度就是文件的长度 char[] cs = data.toCharArray(); fw.write(cs); System.out.println(fw); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; 文件内容： 文件加密练习 准备一个文本文件(非二进制)，其中包含ASCII码的字符和中文字符。设计一个方法 public static void encodeFile(File encodingFile, File encodedFile); 在这个方法中把encodingFile的内容进行加密，然后保存到encodedFile文件中。加密算法：数字：如果不是9的数字，在原来的基础上加1，比如5变成6, 3变成4如果是9的数字，变成0字母字符：如果是非z字符，向右移动一个，比如d变成e, G变成H如果是z，z-&gt;a, Z-A。字符需要保留大小写非字母字符 ，比如’,&amp;^ 保留不变，中文也保留不变 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class TextencodeFile &#123; public static void main(String[] args) &#123; File encodingFile = new File(&quot;F:/winner_info/Learnhow2j/JavaSystem/src/TextFileReader/encodingFile.txt&quot;); File encodedFile = new File(&quot;F:/winner_info/Learnhow2j/JavaSystem/src/TextFileReader/encodedFile.txt&quot;); encodeFile(encodingFile,encodedFile); &#125; public static void encodeFile(File encodingFile,File encodedFile)&#123; //判断文件是否符合加密要求 if (encodingFile.length() == 0)&#123; throw new RuntimeException(&quot;文件不符合加密要求！！！&quot;); &#125; FileReader fr = null; FileWriter fw = null; try&#123; // 创建基于文件的Reader fr = new FileReader(encodingFile); char[] frcontent = new char[(int) encodingFile.length()]; fw = new FileWriter(encodedFile); char[] fwcontent = null; fr.read(frcontent); System.out.print(&quot;加密前的内容：&quot;); System.out.println(new String(frcontent).trim()); encode(frcontent); /*//通过ASCII值判断是否满足要求 for(int i = 0; i &lt; frcontent.length; i++)&#123; char b = frcontent[i]; if (b &gt;= 48 &amp;&amp; b &lt;= 57)&#123; if (b == 57)&#123; b = (char) (b - 9); &#125;else&#123; b = (char) (b + 1); &#125; &#125;else if ((b &gt;= 65 &amp;&amp; b &lt;= 90) || (b &gt;= 97 &amp;&amp; b &lt;= 122))&#123; if (b == 90 || b == 122)&#123; b = (char) (b - 25); &#125;else&#123; b = (char) (b + 1); &#125; &#125;else&#123; &#125; frcontent[i] = b ; &#125;*/ System.out.print(&quot;加密后的内容：&quot;); System.out.println(new String(frcontent).trim()); fw.write(frcontent); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finally&#123; try&#123; if (null != fr)&#123; fr.close(); &#125; if (null != fw)&#123; fw.close(); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; private static void encode(char[] frcontent)&#123; for (int i = 0; i &lt; frcontent.length; i++)&#123; char b = frcontent[i]; if (isLetterOrDigit(b))&#123; switch(b)&#123; case &apos;9&apos;: b = &apos;0&apos;; break; case &apos;z&apos;: b = &apos;a&apos;; break; case &apos;Z&apos;: b = &apos;A&apos;; break; default : b++; break; &#125; &#125; frcontent[i] = b; &#125; &#125; public static boolean isLetterOrDigit(char c)&#123; // 不使用Character类的isLetterOrDigit方法是因为，中文也会被判断为字母 String letterOrDigital = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;; return -1 == letterOrDigital.indexOf(c)? false:true; &#125;&#125; 输出结果： 代码未出现报错，但无法把字符流写入到文件中的情况字节流在操作文件时，即使不关闭资源（close方法），文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容 在获取文本中的内容时，如果出现中文的话，文件的长度会变成中文的两倍。就是如果txt文件中有“中国”两个字，在file.length() 中会变成4，因此本身的字符串数据就变成4个了。在控制台输出的时候，就会有小正方形。 char[] all = new char[(int) f.length()]; 这句查了一下length()返回的是文件的长度（多少个字节），这里是char数组，char占两个字节 相当于2个byte了吧，所以应该大小设置一半（或者一半+1） 就行了吧？如果这个文件里的内容都是数字，则文件的长度与char数组的长度是相等的 字节流和字符流使用是非常相似的，那么除了操作代码的不同之外，还有哪些不同呢？字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的 那开发中究竟用字节流好还是用字符流好呢？在所有的硬盘上保存文件或进行传输的时候都是以字节的方法进行的，包括图片也是按字节完成，而字符是只有在内存中才会形成的，所以使用字节的操作是最多的。 如果要java程序实现一个拷贝功能，应该选用字节流进行操作（可能拷贝的是图片），并且采用边读边写的方式（节省内存）。]]></content>
      <categories>
        <category>Java文件</category>
      </categories>
      <tags>
        <tag>java流/字符流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流]]></title>
    <url>%2Fgit-gao.github.io%2F2018%2F04%2F24%2F%E6%B5%81%2F</url>
    <content type="text"><![CDATA[#流 什么是流？ 流是一个抽象的概念，是一组具有方向性的字节集合，是对数据传输的总体或抽象。数据在输入设备和输出设备之间的传输称之为流。设备可以是文件、网络、内存等。 处理的数据单位不同，可分为：字符流，字节流 数据流方向不同，可分为：输入流，输出流 字节流1.以字节流的形式读取文件内容 InputStream 是字节输入流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。FileInputStream 是InputStream子类，以FileInputStream 为例进行文件读取 ###ASCII码 概念 所有的数据存放在计算机中都是以数字的形式存放的。 所以字母就需要转换为数字才能够存放。 比如A就对应的数字65，a对应的数字97. 不同的字母和符号对应不同的数字，就是一张码表。 ASCII是这样的一种码表。 只包含简单的英文字母，符号，数字等等。 不包含中文，德文，俄语等复杂的。 1234567891011121314151617public static void main(String[] args) &#123; try&#123; File file = new File("F:/winner_info/Learnhow2j/JavaSystem/src/TestFileStream/textStream.txt"); //创建基于文件的输入流 FileInputStream fis = new FileInputStream(file); //创建字节数组，其长度就是文件的长度 byte[] all = new byte[(int) file.length()]; fis.read(all); for (byte b : all)&#123; System.out.println(b); &#125; //使用完流都应该关闭流 fis.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;&#125; 输出结果： 2. 以字节流的形式向文件写入数据 OutputStream是字节输出流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。 FileOutputStream 是OutputStream子类，以FileOutputStream 为例向文件写出数据 1234567891011121314151617public static void main(String[] args) &#123; try&#123; //// 准备文件outputStream.txt其中的内容是空的 File file = new File("F:/winner_info/Learnhow2j/JavaSystem/src/TestFileStream/outputStream.txt"); //准备长度4的字节数，用97,98,65,66初始化 byte data[] = &#123;97,98,65,66&#125;; //创建基于文件的输出流 FileOutputStream fos = new FileOutputStream(file); //将数据写入到输出流 fos.write(data); //关闭输出流 fos.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 注: 如果文件 outputStream.txt不存在，写出操作会自动创建该文件。但是如果是文件 F:/xyz/outputStream.txt，而目录xyz又不存在，会抛出异常 outputStream.txt 文件内容： 练习-拆分文件 找到一个大于100k的文件，按照100k为单位，拆分成多个子文件，并且以编号作为文件名结束。比如文件 eclipse.exe，大小是309k。拆分之后，成为eclipse.exe-0eclipse.exe-1eclipse.exe-2eclipse.exe-3 解题思路分析 文件拆分的详细步骤 1.创建文件对象、设置拆分文件的大小 2.判断文件是否可以分割，将文件的内容读取到字节数组中 3.计算文件按要求可拆分的数量 4.遍历，设置拆分后的文件名、获取文件的路径，以此创建拆分后的文件对象 5.将源文件的内容截取出来存放到拆分后的字节数组中 6.将截取后的内容存放到设置的文件对象中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class SplitFile &#123; public static void main(String[] args) &#123; //创建文件对象 File file = new File("F:/winner_info/Learnhow2j/fileText/filetext.txt"); //设置每个文件的大小 int eachSize = 100*1024; splitFile(eachSize,file); &#125; //创建文件分割的函数 public static void splitFile(int eachSize, File file)&#123; //判断文件是否符合分割要求 if (file.length() == 0)&#123; throw new RuntimeException("文件不符合分割要求！！！"); &#125; byte [] allFile = new byte[(int) file.length()]; try&#123; FileInputStream fin = new FileInputStream(file); //将文件读取到数组中 fin.read(allFile); fin.close(); /*for (byte b: singleFile)&#123; &#125;*/ &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; //计算文件拆分后的数量 int splitfileCount = 0; if ((allFile.length) % eachSize == 0)&#123; splitfileCount = allFile.length / eachSize; &#125;else&#123; splitfileCount = allFile.length / eachSize + 1; &#125; //创建文件名、文件路径 String filePath = file.getParent()+"\\splitFile"; //在当前文件路径下创建拆分的文件,并将内容分别写入到拆分的文件中 try&#123; for (int i = 0; i &lt; splitfileCount; i++)&#123; //创建文件名、文件路径 String fileName = "eclipse.exe-" + i + ".txt"; //创建分割后的文件对象 File splitFile = new File(filePath, fileName); //将源文件内容复制到分割后的文件中,使用copyOfRange()函数 byte[] eachFile; //将源文件的内容截取出来 if (i != splitfileCount - 1)&#123; eachFile = Arrays.copyOfRange(allFile, eachSize*i, eachSize*(i+1)); &#125;else&#123; eachFile = Arrays.copyOfRange(allFile, eachSize*i, allFile.length); &#125; /* * 将截取出来的文件内容再存储到文件中 */ //创建基于文件的输出流 FileOutputStream fos = new FileOutputStream(splitFile); //将数据写入到输出流 fos.write(eachFile); //关闭输出流 fos.close(); System.out.println("输出子文件:" + splitFile.getAbsolutePath() + ", 其大小是:" + splitFile.length() + "字节"); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; //合并分割的文件,合并文件练习，暂时注释// mergeFile(filePath); &#125; 输出结果： 拆分后的文件目录如下： 练习-合并文件 把上述拆分出来的文件，合并成一个原文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 /* * 文件合并方法 */ public static void mergeFile(String filePath)&#123; //通过获取分割后的文件路径，创建文件对象 File file = new File(filePath); //获取该文件目录下的所有文件，listFiles()是带有文件路径的列表，此处用list() String[] splitfileList = file.list(); //合并后的文件存放位置 File mergeFile = new File("F:/winner_info/Learnhow2j/fileText/mergeFile/mergeFile.txt"); OutputStream fos = null; try&#123; //创建基于文件的输出流 fos = new FileOutputStream(mergeFile); //遍历文件目录下的文件，读取内容 for(int i = 0 ; i &lt; splitfileList.length; i++)&#123; //创建文件对象 File spFile = new File(filePath+"/"+splitfileList[i]); //创建文件的输入流 FileInputStream fin = new FileInputStream(spFile); byte[] splitContent = new byte[(int) spFile.length()]; //将文件读取到数组中 int len = fin.read(splitContent); //文件内容写入到输出流 fos.write(splitContent,0,len); //关闭输入流 fin.close(); // System.out.println("合并后的文件:" + mergeFile.getAbsolutePath() + ",其大小是:" + mergeFile.length() + "字节"); &#125; System.out.println("合并后的文件:" + mergeFile.getAbsolutePath() + ",其大小是:" + mergeFile.length() + "字节"); &#125;catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch(IOException e)&#123; e.printStackTrace(); &#125;finally&#123; try&#123; if(fos!=null)&#123; //关闭输出流 fos.close(); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; 输出结果： 合并后的文件： 关闭流 上面的文件拆分的代码在try的作用域中关闭流，这样做有一个弊端： 如果文件不存在或者读取的时候出现问题而抛出异常，那么就不会执行这一行关闭流的代码，存在巨大的资源占用隐患，不推荐使用。 在finally中关闭流这是标准的关闭流的方式，文件合并时就是使用的该方式 首先把流的引用声明在try的外面，如果声明在try里面，其作用域无法抵达finally. 在finally关闭之前，要先判断该引用是否为空 关闭的时候，需要再一次进行try catch处理 把流定义在try()里,try,catch或者finally结束的时候，会自动关闭这种编写代码的方式叫做 try-with-resources， 这是从JDK7开始支持的技术1234567891011121314151617public static void main(String[] args) &#123; //其中的内容是AaBb，对应的ASCII分别是65 97 66 98 File file = new File("F:/winner_info/Learnhow2j/JavaSystem/src/TestFileStream/textStream.txt"); //把流定义在try()里,try,catch或者finally结束的时候，会自动关闭 try(FileInputStream fis = new FileInputStream(file))&#123; //创建字节数组，其长度就是文件的长度 byte[] all = new byte[(int) file.length()]; fis.read(all); for (byte b : all)&#123; System.out.println(b); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;]]></content>
      <categories>
        <category>Java文件</category>
      </categories>
      <tags>
        <tag>java流 I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件基本操作]]></title>
    <url>%2Fgit-gao.github.io%2F2018%2F04%2F14%2F%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[常见文件操作相关的方法（1） 文件绝对路径：getAbsolutePath() 文件是否存在：exists() 判断是否是文件夹：isDirectory() 判断是否是文件：isFile() 获取文件内容的长度：length() 获取文件最后的修改时间：lastModified() 文件重命名：renameTo() 1234567891011121314151617181920212223public class newTestFile &#123; public static void main(String[] args) &#123; File file1 = new File("F:/winner_info/Learnhow2j/JavaSystem/src/TestIO/fileDirectory"); File file2 = new File("file2.txt"); File file = new File(file1,"file2.txt"); System.out.println("当前文件是："+file); System.out.println("绝对路径:"+file.getAbsolutePath()); System.out.println("判断是否存在:"+file.exists()); System.out.println("判断是否是文件夹:"+file.isDirectory()); System.out.println("判断是否是文件:"+file.isFile()); System.out.println("获取文件的长度:"+file.length());//file2.txt:"新文件内容text2" //文件最后修改时间 long time = file.lastModified(); Date date = new Date(time); System.out.println("文件修改的时间戳"+time+",获取文件的最后修改时间："+date); //文件重命名 File file3 = new File("F:/winner_info/Learnhow2j/JavaSystem/src/TestIO/fileDirectory/file3.txt"); file.renameTo(file3); &#125; &#125; 常见文件操作相关的方法（2）123456789101112131415161718192021222324252627282930313233343536public class newTestFile2 &#123; public static void main(String[] args) throws IOException &#123; File file = new File("F:/winner_info/Learnhow2j/JavaSystem/src/TestIO"); // 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件夹的子文件及子文件夹） String[] fis = file.list(); System.out.print("文件列表:"); for (int i = 0 ; i &lt; fis.length; i++)&#123; System.out.print(fis[i]+","); &#125; System.out.println(); // 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹） System.out.print("文件数组:"); File[] fs = file.listFiles(); for (int i = 0 ; i &lt; fs.length; i++)&#123; System.out.println(fs[i]); &#125; // 以字符串形式返回当前文件所在文件夹 System.out.println("当前文件的所在文件夹"+file.getParent()); //以文件形式返回当前文件所在文件夹 System.out.println("当前文件的所在文件夹"+file.getParentFile()); // 如果当前文件夹不存在，则创建该文件夹，如果父文件夹不存在，创建就无效 System.out.println(file.mkdir()); // 创建一个空文件,如果父文件夹不存在，就会抛出异常 System.out.println(file.createNewFile()); // 列出所有的盘符c: d: e: 等等 System.out.print("列出盘符:"); File[] litsR = file.listRoots(); for (int i = 0 ; i &lt; litsR.length; i++)&#123; System.out.println(litsR[i]); &#125; &#125;&#125; 文件目录结构 输出结果： 小练习 一般说来操作系统都会安装在C盘，所以会有一个 C:\WINDOWS目录。 遍历这个目录下所有的文件(不用遍历子目录)找出这些文件里，最大的和最小(非0)的那个文件，打印出他们的文件名 注: 最小的文件不能是0长度 12345678910111213141516171819202122232425public static void main(String[] args) throws IOException&#123; File file = new File("C:/WINDOWS"); //以文件数组的形式，获取当前文件夹下的所有文件 File[] filist = file.listFiles(); //最大整形 2147483648 long minSize = Integer.MAX_VALUE; long maxSize = 0; File maxL = null; File minL = null; for (int i = 0; i &lt; filist.length; i++)&#123; if(filist[i].isDirectory())&#123; continue; &#125; if (maxSize &lt; filist[i].length())&#123; maxSize = filist[i].length(); maxL = filist[i+1]; &#125; if (minSize &gt; filist[i].length()&amp;&amp; filist[i].length() != 0)&#123; minSize = filist[i].length(); minL = filist[i+1]; &#125; &#125; System.out.println("最大文件：" + maxL+",长度："+maxSize); System.out.println("最小文件：" + minL+",长度："+minSize); &#125; 输出结果： 上例，遍历子所有文件包括文件及下的子文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class traversalFiles2 &#123; static long minSize = Integer.MAX_VALUE; static long maxSize = 0; static File maxL = null; static File minL = null; //使用递归来遍历一个文件夹的子文件 public static void listFiles(File file)&#123; //如果是文件则判断文件的大小 if (file.isFile())&#123; if(maxSize &lt; file.length())&#123; maxSize = file.length(); maxL = file; &#125; if (minSize &gt; file.length()&amp;&amp; file.length() != 0)&#123; minSize = file.length(); minL = file; &#125; return; &#125; if (file.isDirectory())&#123; File[] fileList = file.listFiles(); //如果不是空文件夹，则遍历 if(null != fileList)&#123; for (File fs : fileList)&#123; listFiles(fs); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; File file = new File("C:/WINDOWS"); //以文件数组的形式，获取当前文件夹下的所有文件 System.out.println("正在查找..."); //开始时间 long starTime=System.currentTimeMillis(); //开始遍历子文件 listFiles(file); //结束时间 long endTime=System.currentTimeMillis(); //运行时间 long Time=endTime-starTime; System.out.println("最大的文件是:"+ maxL.getAbsolutePath()+",其大小为："+maxSize); System.out.println("最小的文件是:"+ minL.getAbsolutePath()+",其大小为："+minSize); System.out.println("程序运行时间:"+Time/1000+"s"); &#125;&#125; 输出结果:]]></content>
      <categories>
        <category>Java文件</category>
      </categories>
      <tags>
        <tag>文件对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java异常]]></title>
    <url>%2Fgit-gao.github.io%2F2018%2F04%2F11%2Fjava%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[什么是异常Java 异常是 Java 提供的一种识别及响应错误的一致性机制 例如打开本地的一个文件，如下代码，这个时候 FileInputStream 编译时会报错，提示 FileNotFoundException123456789package exception; import java.io.File; import java.io.FileInputStream; public class TestException &#123; public static void main(String[] args) &#123; File f = new File("F:/winner_info/Learnhow2j/e_tex.txt"); new FileInputStream(f); &#125; &#125; 使用异常处理机制 try-catch ，不管是文件路径不对还是文件不存在都可以避免异常 本地文件为 e_text.txt 123456789101112131415161718package Testexcption;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;public class FirstExcptionTest &#123; public static void main(String[] args) &#123; File f = new File("F:/winner_info/Learnhow2j/e_tex.txt"); try&#123; new FileInputStream(f); System.out.println("文件打开成功！"); &#125;catch (FileNotFoundException e)&#123; System.out.println("文件打开失败！"); e.printStackTrace(); &#125; &#125;&#125; 控制台打印出来的信息是 java.io.FileNotFoundException printStackTrace()方法的意思是：在命令行打印异常信息在程序中出错的位置及原因。 当使用 System.out.println(e) 时，也会打印错误信息，但仅显示1java.io.FileNotFoundException: F:\winner_info\Learnhow2j\e_tex.txt (系统找不到指定的文件。) e.printStackTrace();是打印异常的堆栈信息，指明错误原因，其实当发生异常时，通常要处理异常，这是编程的好习惯，所以e.printStackTrace()可以方便你调试程序！ 异常处理 多个异常需要处理时，这样可以这样写，好处是捕捉的代码更紧凑，不足之处是，一旦发生异常，不能确定到底是哪种异常，需要通过 instanceof 进行判断具体的异常类型 1catch (FileNotFoundException | ParseException e) 或者分别进行catch，这种方法能清晰的了解异常出现的具体情况。 1234567891011121314catch (FileNotFoundException e)&#123; if (e instanceof FileNotFoundException)&#123; System.out.println("文件打开失败！"); &#125; e.printStackTrace(); System.out.println(e);&#125;catch(ParseException e)&#123; if (e instanceof ParseException)&#123; System.out.println("日期解析错误！"); &#125; e.printStackTrace(); System.out.println(e);&#125; 异常都是Exception的子类，使用Exception一起catch 123456789101112131415try&#123; new FileInputStream(f); System.out.println("文件打开成功！"); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Date data = sdf.parse("2018-0");&#125;catch (Exception e)&#123; if (e instanceof FileNotFoundException)&#123; System.out.println("文件打开失败！"); &#125; if (e instanceof ParseException)&#123; System.out.println("日期解析错误！"); &#125; e.printStackTrace(); System.out.println(e);&#125; finally语句块 finally 语句块并不一定是会执行的，finally 语句块是在 try 或者 catch 中的 return 语句之前执行的 123456789101112131415161718public class finallyTest &#123; public static void main(String[] args) &#123; System.out.println("reture value of test() : " + test()); &#125; public static int test()&#123; int i = 1; try &#123; System.out.println("try block"); i = 1 / 0; //出现异常 return 1; &#125;catch (Exception e)&#123; System.out.println("exception block"); return 2; &#125;finally &#123; System.out.println("finally block"); &#125; &#125; &#125; 运行结果： 关于 finally 的研究可以参考链接https://www.ibm.com/developerworks/cn/java/j-lo-finally/ throw 异常抛出主方法调用method1method1调用method2method2中解析日期 method2中需要进行异常处理但是method2不打算处理，而是把这个异常通过throws抛出去那么method1就会接到该异常。 处理办法也是两种，要么是try catch处理掉，要么也是抛出去。 method1选择本地try catch住 一旦try catch住了，就相当于把这个异常消化掉了，主方法在调用method1的时候，就不需要进行异常处理了1234567891011121314151617181920public class throwException &#123; public static void main(String[] args)&#123; methord1(); &#125; public static void methord1()&#123; try&#123; methord2(); &#125;catch(Exception e)&#123; System.out.println("日期解析失败！"); e.printStackTrace(); &#125; &#125; public static void methord2()throws Exception&#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Date data = sdf.parse("18-01"); System.out.println("日期解析成功！"); &#125;&#125; 输出结果： throws与throw这两个关键字接近，不过意义不一样，有如下区别： throws 出现在方法声明上，而throw通常都出现在方法体内。 throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某个异常对象。 异常分类 运行异常 异常可分为运行异常（RuntimeException）和检查异常（Checked Exceptions）两种 RuntimeException 在默认情况下会得到自动处理。所以通常用不着捕获 RuntimeException Runtime 如除数是 0 和数组下标越界等，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大。 例如常见的运行时异常： ArithmeticException，ArrayIndexOutOfBoundsException，NullPointerException 123456789101112public static void main(String[] args)&#123; //任何除数不能为0:ArithmeticException int k = 5 / 0; //下标越界异常：ArrayIndexOutOfBoundsException int a[] = new int[3]; a[5] = 5; //空指针异常：NullPointerException String str = null; str.length();&#125; 检查异常除了runtimeException以外的异常，都属于checkedException 只有java语言提供了Checked异常，Java认为Checked异常都是可以被处理的异常，所以Java程序必须显示处理Checked异常 例如上文的 FileNotFoundException、ParseException、ClassNotFoundException，在编译之前就需要进行异常的处理，否则无法通过编译。 对Checked异常处理方法有两种 当前方法知道如何处理该异常，则用try…catch块来处理该异常。 当前方法不知道如何处理，则在定义该方法是声明抛出该异常。 Error与异常不同的是Error及其子类的对象不应被抛出。 当程序发生不可控这种错误时，通常的做法是通知用户并中止程序的执行。 Error 是 Throwable 的子类，代表编译时间和系统错误，用于指示合理的应用程序不应该试图捕获的严重问题。]]></content>
      <categories>
        <category>Java异常处理</category>
      </categories>
      <tags>
        <tag>java 异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS定位流]]></title>
    <url>%2Fgit-gao.github.io%2F2018%2F04%2F07%2FCSS%E5%AE%9A%E4%BD%8D%E6%B5%81%2F</url>
    <content type="text"><![CDATA[CSS的定位方式absolute, relative, fixed，static css共有四种定位分别是：相对定位、绝对定位、静态定位、固定定位。 相对定位 相对定位：相对自己之前在标准流中的定位，不是父元素的左上角 我们来举个实例123456789101112131415161718192021&lt;style type="text/css"&gt; .box&#123; width: 500px; height: 400px; border: 1px solid red; margin: 100px auto; &#125; div&#123; width: 100px; height: 100px; &#125; .box1&#123; background: red; &#125; .box2&#123; background: blue; &#125; .box3&#123; background: green; &#125;&lt;/style&gt; 1234567&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;box3&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 现在我们将 box2 进行相对定位 12345.box2&#123; position: relative; top: 10px; left: 10px;&#125; 结果如图所示 相对定位：position:relative，不脱离标准流，我们设置方向上的定位属性来改变盒子的位置，但是同一方向上只能设置一个方向属性，例如 left和 right 只能设置其一，如果两个属性都设置了，只有 left 起作用，right 无效。 由于相对定位不脱离标准流，所以当为元素设置 margin/padding 属性时会影响页面的布局 123.box2&#123; margin-top: 20px;&#125; 当给 box2 设置 margin-top: 20xp 时，box3 也随着 box2 下降了20px距离，具体的原理如图： 首先 box2 上左各移动 20px 如下图： 然后 box2 再 margin-top：20px 注意一点：margin 不会加给定位之后的元素，而是定位之前的元素 所以 此时的位置变化如图： 标准流中的 box2 下移 20px，box3被box2往下挤 20px ，而 box2 又设置了 top:10px，因而就出现了上图的变化过程。 相对定位不脱离标准流，故而是区分块级元素/行内元素/行内块级元素 绝对定位绝对定位就是相对于body或者某个定位流中的祖先元素来定位 绝对定位：position:absolute; 绝对定位的元素脱离标准流，因为绝对定位的元素不区分块级元素/行内元素/行内块级元素 依旧将改变 box2 的定位属性123456.box2&#123; background: blue; position: absolute; top: 10px; left: 10px;&#125; 我们看到 box2 脱离了 box 的范围，移到了 body 的旁边，仔细发现其实是 box2 距离 body 的 top:10px ，left:10px 。 由上可知，默认情况下绝对定位元素是相对于body定位的 现在我们也将 box 元素设置为定位流 position:absolute，来看看效果 1234567891011121314151617181920212223242526272829&lt;style type="text/css"&gt; body&#123; background: #23241f; color: #fff; &#125; .box&#123; width: 500px; height: 400px; border: 1px solid red; margin: 100px auto; position: absolute; &#125; div&#123; width: 100px; height: 100px; &#125; .box1&#123; background: red; &#125; .box2&#123; background: blue; position: absolute; top: 10px; left: 10px; &#125; .box3&#123; background: green; &#125;&lt;/style&gt; 1234567&lt;body&gt; &lt;div class="box"&gt; &lt;div class="box1"&gt;box1&lt;/div&gt; &lt;div class="box2"&gt;box2&lt;/div&gt; &lt;div class="box3"&gt;box3&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 此时 box2 是相对 box 父元素定位的。 如果一个绝对定位的元素有祖先元素，并且祖先元素也是定位流，那么绝对定位的元素就会以定位流的祖先元素作为定位参考点。 如果将 box 的position:absolute 改为 position:static123.box&#123; position: static;&#125; 发现并 没有起作用。box2 还是相对 body 定位的。 祖先元素的定位流指的是绝对定位(absolute)、相对定位(relative)、固定定位(fixed)，静态定位无效 现在又有如下例子，设置box2有多个父元素1234567891011121314151617181920212223242526272829&lt;style type="text/css"&gt; body&#123; background: #23241f; color: #fff; &#125; .box&#123; width: 500px; height: 400px; border: 1px solid red; margin: 100px auto; position: absolute; &#125; .box1&#123; width: 300px; height: 300px; background: red; position: absolute; left: 50px; top: 50px &#125; .box2&#123; width: 80px; height: 80px; background: blue; position: absolute; top: 10px; left: 10px; &#125;&lt;/style&gt; 1234567&lt;body&gt; &lt;div class="box"&gt; &lt;div class="box1"&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 当 box2 的父元素 box1 和 box 都设置了 position:absolute属性时，box2是相对于 box1 定位的。 如果一个绝对定位的元素有多个祖先元素，并且祖先元素都是定位流，那么这个绝对定位的元素以离他最近的那个定位流祖先元素作为参考点 绝对定位两个注意点 如果定位流元素是以body作为参考点，那么其实是以网页首屏的宽度和高度作为参考点，而不是整个网页的宽高 绝对定位的元素会忽略祖先元素的 padding 固定定位固定定位：position:fixed，这个属性与绝对定位的用法几乎一样，区别在于，固定定位的元素不会随着浏览器的大小变化改变位置，也不会随着滚动条的移动而移动。123456789101112131415161718192021222324252627&lt;style&gt; body&#123; background: #23241f; color: #fff; &#125; .box&#123; width: 500px; height: 1200px; border: 1px solid red; margin: 100px 600px; position: relative; &#125; .box1&#123; width: 300px; height: 300px; background: red; position: fixed; &#125; .box2&#123; width: 80px; height: 80px; background: blue; position: absolute; left: 10px; top: 10px; &#125;&lt;/style&gt; 另外，我们知道绝对定位的元素是以离最近的定位流元素作为参照点的 现在我们设置 box1 的偏移量12345678.box1&#123; width: 300px; height: 300px; background: red; position: fixed; right: 20px; top: 20px;&#125; 虽然给 box1 最近的元素 box 设置了 position:relative，但是它依然是相对 body 定位的 固定定位（fixed）的参照点默认是浏览器的左上角，而且始终以 body 作为参照点。 静态定位 默认元素就是静态定位，静态定位(static)不能作为元素定位的参照点]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fgit-gao.github.io%2F2018%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
