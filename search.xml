<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[文件基本操作]]></title>
    <url>%2Fgit-gao.github.io%2F2018%2F04%2F14%2F%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[常见文件操作相关的方法（1） 文件绝对路径：getAbsolutePath() 文件是否存在：exists() 判断是否是文件夹：isDirectory() 判断是否是文件：isFile() 获取文件内容的长度：length() 获取文件最后的修改时间：lastModified() 文件重命名：renameTo() 1234567891011121314151617181920212223public class newTestFile &#123; public static void main(String[] args) &#123; File file1 = new File("F:/winner_info/Learnhow2j/JavaSystem/src/TestIO/fileDirectory"); File file2 = new File("file2.txt"); File file = new File(file1,"file2.txt"); System.out.println("当前文件是："+file); System.out.println("绝对路径:"+file.getAbsolutePath()); System.out.println("判断是否存在:"+file.exists()); System.out.println("判断是否是文件夹:"+file.isDirectory()); System.out.println("判断是否是文件:"+file.isFile()); System.out.println("获取文件的长度:"+file.length());//file2.txt:"新文件内容text2" //文件最后修改时间 long time = file.lastModified(); Date date = new Date(time); System.out.println("文件修改的时间戳"+time+",获取文件的最后修改时间："+date); //文件重命名 File file3 = new File("F:/winner_info/Learnhow2j/JavaSystem/src/TestIO/fileDirectory/file3.txt"); file.renameTo(file3); &#125; &#125; 常见文件操作相关的方法（2）123456789101112131415161718192021222324252627282930313233343536public class newTestFile2 &#123; public static void main(String[] args) throws IOException &#123; File file = new File("F:/winner_info/Learnhow2j/JavaSystem/src/TestIO"); // 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件夹的子文件及子文件夹） String[] fis = file.list(); System.out.print("文件列表:"); for (int i = 0 ; i &lt; fis.length; i++)&#123; System.out.print(fis[i]+","); &#125; System.out.println(); // 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹） System.out.print("文件数组:"); File[] fs = file.listFiles(); for (int i = 0 ; i &lt; fs.length; i++)&#123; System.out.println(fs[i]); &#125; // 以字符串形式返回当前文件所在文件夹 System.out.println("当前文件的所在文件夹"+file.getParent()); //以文件形式返回当前文件所在文件夹 System.out.println("当前文件的所在文件夹"+file.getParentFile()); // 如果当前文件夹不存在，则创建该文件夹，如果父文件夹不存在，创建就无效 System.out.println(file.mkdir()); // 创建一个空文件,如果父文件夹不存在，就会抛出异常 System.out.println(file.createNewFile()); // 列出所有的盘符c: d: e: 等等 System.out.print("列出盘符:"); File[] litsR = file.listRoots(); for (int i = 0 ; i &lt; litsR.length; i++)&#123; System.out.println(litsR[i]); &#125; &#125;&#125; 文件目录结构 输出结果： 小练习 一般说来操作系统都会安装在C盘，所以会有一个 C:\WINDOWS目录。 遍历这个目录下所有的文件(不用遍历子目录)找出这些文件里，最大的和最小(非0)的那个文件，打印出他们的文件名 注: 最小的文件不能是0长度 12345678910111213141516171819202122232425public static void main(String[] args) throws IOException&#123; File file = new File("C:/WINDOWS"); //以文件数组的形式，获取当前文件夹下的所有文件 File[] filist = file.listFiles(); //最大整形 2147483648 long minSize = Integer.MAX_VALUE; long maxSize = 0; File maxL = null; File minL = null; for (int i = 0; i &lt; filist.length; i++)&#123; if(filist[i].isDirectory())&#123; continue; &#125; if (maxSize &lt; filist[i].length())&#123; maxSize = filist[i].length(); maxL = filist[i+1]; &#125; if (minSize &gt; filist[i].length()&amp;&amp; filist[i].length() != 0)&#123; minSize = filist[i].length(); minL = filist[i+1]; &#125; &#125; System.out.println("最大文件：" + maxL+",长度："+maxSize); System.out.println("最小文件：" + minL+",长度："+minSize); &#125; 上例，遍历子所有文件包括文件及下的子文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class traversalFiles2 &#123; static long minSize = Integer.MAX_VALUE; static long maxSize = 0; static File maxL = null; static File minL = null; //使用递归来遍历一个文件夹的子文件 public static void listFiles(File file)&#123; //如果是文件则判断文件的大小 if (file.isFile())&#123; if(maxSize &lt; file.length())&#123; maxSize = file.length(); maxL = file; &#125; if (minSize &gt; file.length()&amp;&amp; file.length() != 0)&#123; minSize = file.length(); minL = file; &#125; return; &#125; if (file.isDirectory())&#123; File[] fileList = file.listFiles(); //如果不是空文件夹，则遍历 if(null != fileList)&#123; for (File fs : fileList)&#123; listFiles(fs); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; File file = new File("C:/WINDOWS"); //以文件数组的形式，获取当前文件夹下的所有文件 System.out.println("正在查找..."); //开始时间 long starTime=System.currentTimeMillis(); //开始遍历子文件 listFiles(file); //结束时间 long endTime=System.currentTimeMillis(); //运行时间 long Time=endTime-starTime; System.out.println("最大的文件是:"+ maxL.getAbsolutePath()+",其大小为："+maxSize); System.out.println("最小的文件是:"+ minL.getAbsolutePath()+",其大小为："+minSize); System.out.println("程序运行时间:"+Time/1000+"s"); &#125;&#125; 输出结果:]]></content>
      <categories>
        <category>Java文件</category>
      </categories>
      <tags>
        <tag>文件对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java异常]]></title>
    <url>%2Fgit-gao.github.io%2F2018%2F04%2F11%2Fjava%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[什么是异常Java 异常是 Java 提供的一种识别及响应错误的一致性机制 例如打开本地的一个文件，如下代码，这个时候 FileInputStream 编译时会报错，提示 FileNotFoundException123456789package exception; import java.io.File; import java.io.FileInputStream; public class TestException &#123; public static void main(String[] args) &#123; File f = new File("F:/winner_info/Learnhow2j/e_tex.txt"); new FileInputStream(f); &#125; &#125; 使用异常处理机制 try-catch ，不管是文件路径不对还是文件不存在都可以避免异常 本地文件为 e_text.txt 123456789101112131415161718package Testexcption;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;public class FirstExcptionTest &#123; public static void main(String[] args) &#123; File f = new File("F:/winner_info/Learnhow2j/e_tex.txt"); try&#123; new FileInputStream(f); System.out.println("文件打开成功！"); &#125;catch (FileNotFoundException e)&#123; System.out.println("文件打开失败！"); e.printStackTrace(); &#125; &#125;&#125; 控制台打印出来的信息是 java.io.FileNotFoundException printStackTrace()方法的意思是：在命令行打印异常信息在程序中出错的位置及原因。 当使用 System.out.println(e) 时，也会打印错误信息，但仅显示1java.io.FileNotFoundException: F:\winner_info\Learnhow2j\e_tex.txt (系统找不到指定的文件。) e.printStackTrace();是打印异常的堆栈信息，指明错误原因，其实当发生异常时，通常要处理异常，这是编程的好习惯，所以e.printStackTrace()可以方便你调试程序！ 异常处理 多个异常需要处理时，这样可以这样写，好处是捕捉的代码更紧凑，不足之处是，一旦发生异常，不能确定到底是哪种异常，需要通过 instanceof 进行判断具体的异常类型 1catch (FileNotFoundException | ParseException e) 或者分别进行catch，这种方法能清晰的了解异常出现的具体情况。 1234567891011121314catch (FileNotFoundException e)&#123; if (e instanceof FileNotFoundException)&#123; System.out.println("文件打开失败！"); &#125; e.printStackTrace(); System.out.println(e);&#125;catch(ParseException e)&#123; if (e instanceof ParseException)&#123; System.out.println("日期解析错误！"); &#125; e.printStackTrace(); System.out.println(e);&#125; 异常都是Exception的子类，使用Exception一起catch 123456789101112131415try&#123; new FileInputStream(f); System.out.println("文件打开成功！"); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Date data = sdf.parse("2018-0");&#125;catch (Exception e)&#123; if (e instanceof FileNotFoundException)&#123; System.out.println("文件打开失败！"); &#125; if (e instanceof ParseException)&#123; System.out.println("日期解析错误！"); &#125; e.printStackTrace(); System.out.println(e);&#125; finally语句块 finally 语句块并不一定是会执行的，finally 语句块是在 try 或者 catch 中的 return 语句之前执行的 123456789101112131415161718public class finallyTest &#123; public static void main(String[] args) &#123; System.out.println("reture value of test() : " + test()); &#125; public static int test()&#123; int i = 1; try &#123; System.out.println("try block"); i = 1 / 0; //出现异常 return 1; &#125;catch (Exception e)&#123; System.out.println("exception block"); return 2; &#125;finally &#123; System.out.println("finally block"); &#125; &#125; &#125; 运行结果： 关于 finally 的研究可以参考链接https://www.ibm.com/developerworks/cn/java/j-lo-finally/ throw 异常抛出主方法调用method1method1调用method2method2中解析日期 method2中需要进行异常处理但是method2不打算处理，而是把这个异常通过throws抛出去那么method1就会接到该异常。 处理办法也是两种，要么是try catch处理掉，要么也是抛出去。 method1选择本地try catch住 一旦try catch住了，就相当于把这个异常消化掉了，主方法在调用method1的时候，就不需要进行异常处理了1234567891011121314151617181920public class throwException &#123; public static void main(String[] args)&#123; methord1(); &#125; public static void methord1()&#123; try&#123; methord2(); &#125;catch(Exception e)&#123; System.out.println("日期解析失败！"); e.printStackTrace(); &#125; &#125; public static void methord2()throws Exception&#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Date data = sdf.parse("18-01"); System.out.println("日期解析成功！"); &#125;&#125; 输出结果： throws与throw这两个关键字接近，不过意义不一样，有如下区别： throws 出现在方法声明上，而throw通常都出现在方法体内。 throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某个异常对象。 异常分类 运行异常 异常可分为运行异常（RuntimeException）和检查异常（Checked Exceptions）两种 RuntimeException 在默认情况下会得到自动处理。所以通常用不着捕获 RuntimeException Runtime 如除数是 0 和数组下标越界等，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大。 例如常见的运行时异常： ArithmeticException，ArrayIndexOutOfBoundsException，NullPointerException 123456789101112public static void main(String[] args)&#123; //任何除数不能为0:ArithmeticException int k = 5 / 0; //下标越界异常：ArrayIndexOutOfBoundsException int a[] = new int[3]; a[5] = 5; //空指针异常：NullPointerException String str = null; str.length();&#125; 检查异常除了runtimeException以外的异常，都属于checkedException 只有java语言提供了Checked异常，Java认为Checked异常都是可以被处理的异常，所以Java程序必须显示处理Checked异常 例如上文的 FileNotFoundException、ParseException、ClassNotFoundException，在编译之前就需要进行异常的处理，否则无法通过编译。 对Checked异常处理方法有两种 当前方法知道如何处理该异常，则用try…catch块来处理该异常。 当前方法不知道如何处理，则在定义该方法是声明抛出该异常。 Error与异常不同的是Error及其子类的对象不应被抛出。 当程序发生不可控这种错误时，通常的做法是通知用户并中止程序的执行。 Error 是 Throwable 的子类，代表编译时间和系统错误，用于指示合理的应用程序不应该试图捕获的严重问题。]]></content>
      <tags>
        <tag>java 异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS定位流]]></title>
    <url>%2Fgit-gao.github.io%2F2018%2F04%2F07%2FCSS%E5%AE%9A%E4%BD%8D%E6%B5%81%2F</url>
    <content type="text"><![CDATA[CSS的定位方式absolute, relative, fixed，static css共有四种定位分别是：相对定位、绝对定位、静态定位、固定定位。 相对定位 相对定位：相对自己之前在标准流中的定位，不是父元素的左上角 我们来举个实例123456789101112131415161718192021&lt;style type="text/css"&gt; .box&#123; width: 500px; height: 400px; border: 1px solid red; margin: 100px auto; &#125; div&#123; width: 100px; height: 100px; &#125; .box1&#123; background: red; &#125; .box2&#123; background: blue; &#125; .box3&#123; background: green; &#125;&lt;/style&gt; 1234567&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;box3&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 现在我们将 box2 进行相对定位 12345.box2&#123; position: relative; top: 10px; left: 10px;&#125; 结果如图所示 相对定位：position:relative，不脱离标准流，我们设置方向上的定位属性来改变盒子的位置，但是同一方向上只能设置一个方向属性，例如 left和 right 只能设置其一，如果两个属性都设置了，只有 left 起作用，right 无效。 由于相对定位不脱离标准流，所以当为元素设置 margin/padding 属性时会影响页面的布局 123.box2&#123; margin-top: 20px;&#125; 当给 box2 设置 margin-top: 20xp 时，box3 也随着 box2 下降了20px距离，具体的原理如图： 首先 box2 上左各移动 20px 如下图： 然后 box2 再 margin-top：20px 注意一点：margin 不会加给定位之后的元素，而是定位之前的元素 所以 此时的位置变化如图： 标准流中的 box2 下移 20px，box3被box2往下挤 20px ，而 box2 又设置了 top:10px，因而就出现了上图的变化过程。 相对定位不脱离标准流，故而是区分块级元素/行内元素/行内块级元素 绝对定位绝对定位就是相对于body或者某个定位流中的祖先元素来定位 绝对定位：position:absolute; 绝对定位的元素脱离标准流，因为绝对定位的元素不区分块级元素/行内元素/行内块级元素 依旧将改变 box2 的定位属性123456.box2&#123; background: blue; position: absolute; top: 10px; left: 10px;&#125; 我们看到 box2 脱离了 box 的范围，移到了 body 的旁边，仔细发现其实是 box2 距离 body 的 top:10px ，left:10px 。 由上可知，默认情况下绝对定位元素是相对于body定位的 现在我们也将 box 元素设置为定位流 position:absolute，来看看效果 1234567891011121314151617181920212223242526272829&lt;style type="text/css"&gt; body&#123; background: #23241f; color: #fff; &#125; .box&#123; width: 500px; height: 400px; border: 1px solid red; margin: 100px auto; position: absolute; &#125; div&#123; width: 100px; height: 100px; &#125; .box1&#123; background: red; &#125; .box2&#123; background: blue; position: absolute; top: 10px; left: 10px; &#125; .box3&#123; background: green; &#125;&lt;/style&gt; 1234567&lt;body&gt; &lt;div class="box"&gt; &lt;div class="box1"&gt;box1&lt;/div&gt; &lt;div class="box2"&gt;box2&lt;/div&gt; &lt;div class="box3"&gt;box3&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 此时 box2 是相对 box 父元素定位的。 如果一个绝对定位的元素有祖先元素，并且祖先元素也是定位流，那么绝对定位的元素就会以定位流的祖先元素作为定位参考点。 如果将 box 的position:absolute 改为 position:static123.box&#123; position: static;&#125; 发现并 没有起作用。box2 还是相对 body 定位的。 祖先元素的定位流指的是绝对定位(absolute)、相对定位(relative)、固定定位(fixed)，静态定位无效 现在又有如下例子，设置box2有多个父元素1234567891011121314151617181920212223242526272829&lt;style type="text/css"&gt; body&#123; background: #23241f; color: #fff; &#125; .box&#123; width: 500px; height: 400px; border: 1px solid red; margin: 100px auto; position: absolute; &#125; .box1&#123; width: 300px; height: 300px; background: red; position: absolute; left: 50px; top: 50px &#125; .box2&#123; width: 80px; height: 80px; background: blue; position: absolute; top: 10px; left: 10px; &#125;&lt;/style&gt; 1234567&lt;body&gt; &lt;div class="box"&gt; &lt;div class="box1"&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 当 box2 的父元素 box1 和 box 都设置了 position:absolute属性时，box2是相对于 box1 定位的。 如果一个绝对定位的元素有多个祖先元素，并且祖先元素都是定位流，那么这个绝对定位的元素以离他最近的那个定位流祖先元素作为参考点 绝对定位两个注意点 如果定位流元素是以body作为参考点，那么其实是以网页首屏的宽度和高度作为参考点，而不是整个网页的宽高 绝对定位的元素会忽略祖先元素的 padding 固定定位固定定位：position:fixed，这个属性与绝对定位的用法几乎一样，区别在于，固定定位的元素不会随着浏览器的大小变化改变位置，也不会随着滚动条的移动而移动。123456789101112131415161718192021222324252627&lt;style&gt; body&#123; background: #23241f; color: #fff; &#125; .box&#123; width: 500px; height: 1200px; border: 1px solid red; margin: 100px 600px; position: relative; &#125; .box1&#123; width: 300px; height: 300px; background: red; position: fixed; &#125; .box2&#123; width: 80px; height: 80px; background: blue; position: absolute; left: 10px; top: 10px; &#125;&lt;/style&gt; 另外，我们知道绝对定位的元素是以离最近的定位流元素作为参照点的 现在我们设置 box1 的偏移量12345678.box1&#123; width: 300px; height: 300px; background: red; position: fixed; right: 20px; top: 20px;&#125; 虽然给 box1 最近的元素 box 设置了 position:relative，但是它依然是相对 body 定位的 固定定位（fixed）的参照点默认是浏览器的左上角，而且始终以 body 作为参照点。 静态定位 默认元素就是静态定位，静态定位(static)不能作为元素定位的参照点]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fgit-gao.github.io%2F2018%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
